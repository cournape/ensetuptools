*** ../../setuptools-0.6c9/pkg_resources.py	2008-09-24 12:10:45.000000000 -0500
--- ../pkg_resources.py	2009-05-14 11:23:56.000000000 -0500
***************
*** 24,44 ****
  from os import open as os_open
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  def get_supported_platform():
      """Return this platform's maximum compatible version.
  
--- 24,29 ----
***************
*** 61,85 ****
      return plat
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  __all__ = [
      # Basic resource access and distribution/entry point discovery
      'require', 'run_script', 'get_provider',  'get_distribution',
--- 46,51 ----
***************
*** 103,109 ****
      # Parsing functions and string utilities
      'parse_requirements', 'parse_version', 'safe_name', 'safe_version',
      'get_platform', 'compatible_platforms', 'yield_lines', 'split_sections',
!     'safe_extra', 'to_filename',
  
      # filesystem utilities
      'ensure_directory', 'normalize_path',
--- 69,75 ----
      # Parsing functions and string utilities
      'parse_requirements', 'parse_version', 'safe_name', 'safe_version',
      'get_platform', 'compatible_platforms', 'yield_lines', 'split_sections',
!     'safe_extra', 'to_filename', 'compose_version_string',
  
      # filesystem utilities
      'ensure_directory', 'normalize_path',
***************
*** 136,143 ****
  _provider_factories = {}
  PY_MAJOR = sys.version[:3]
  EGG_DIST    = 3
! BINARY_DIST = 2
! SOURCE_DIST = 1
  CHECKOUT_DIST = 0
  DEVELOP_DIST = -1
  
--- 102,109 ----
  _provider_factories = {}
  PY_MAJOR = sys.version[:3]
  EGG_DIST    = 3
! SOURCE_DIST = 2
! BINARY_DIST = 1
  CHECKOUT_DIST = 0
  DEVELOP_DIST = -1
  
***************
*** 182,187 ****
--- 148,159 ----
  
      XXX Currently this is the same as ``distutils.util.get_platform()``, but it
      needs some hacks for Linux and Mac OS X.
+ 
+     On platforms where the host OS may have a different architecture than the
+     python executable, i.e when a 64-bit OS is running a 32-bit executable, we
+     need to clarify things further.  We try to detect these cases and change
+     the platform string appropriately.
+ 
      """
      from distutils.util import get_platform
      plat = get_platform()
***************
*** 195,200 ****
--- 167,177 ----
              # if someone is running a non-Mac darwin system, this will fall
              # through to the default implementation
              pass
+ 
+     # If we can determine the architecture of the python executable itself,
+     # then use it instead of what distutils returns about the host OS's
+     # architecture.
+     #return _get_python_platform(plat)
      return plat
  
  macosVersionString = re.compile(r"macosx-(\d+)\.(\d+)-(.*)")
***************
*** 202,207 ****
--- 179,244 ----
  get_platform = get_build_platform   # XXX backward compat
  
  
+ _python_arch = None
+ def _get_python_platform(plat):
+     """ Return the platform spec of python executable.
+ 
+     This massages an existing host-based platform spec IFF we can tell whether
+     the Python executable is different. i.e. a 32-bit executable on a 64-bit
+     host OS.
+ 
+     For performance, this method is designed to cache the Python architecture
+     once it is computed.
+ 
+     """
+     global _python_arch
+     if _python_arch is None:
+         
+         # On Solaris, we can use elfdump to determine the arch of the python
+         # executable.
+         if sys.platform.startswith('sunos'):
+             import subprocess as sp
+             proc = sp.Popen(['/usr/ccs/bin/elfdump', '-e', sys.executable],
+                 stdout=sp.PIPE)
+             for line in proc.communicate()[0].splitlines():
+                 line = line.strip()
+                 if line.startswith('e_machine:'):
+                     elf_machine = line.split()[1]
+                     _python_arch = _get_arch_from_elf_machine(elf_machine)
+                     break
+ 
+         # On all other systems, we don't yet know how to find the architecture
+         # of the Python executable so a non-True value tells our callers to
+         # ignore our value.
+         else:
+             _python_arch = ''
+ 
+     # Massage the platform to replace the machine spec if we found a Python
+     # machine spec.
+     if _python_arch:
+         parts = plat.split('-')
+         parts[-1] = _python_arch
+         plat = '-'.join(parts)
+ 
+     return plat
+ 
+ 
+ def _get_arch_from_elf_machine(machine):
+     """ Return a usable arch spec from an elf machine spec.
+ 
+     The values we know of for e_machine come from the listing on the webpage:
+         http://www.sco.com/developers/gabi/latest/ch4.eheader.html
+     It is assumed that these are the same across different OS platforms and
+     releases.  If they are found not to be, we should refactor this into
+     methods per OS.
+     """
+     return {
+         # This dictionary handles where the value we want isn't the suffix.
+         'EM_386': 'x86',
+         'EM_SPARC32PLUS': 'sparc32',
+         'EM_IA_64': 'ia64',
+         }.get(machine, machine[3:].lower())
+ 
  
  def compatible_platforms(provided,required):
      """Can code for the `provided` platform run on the `required` platform?
***************
*** 311,331 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class IResourceProvider(IMetadataProvider):
      """An object that provides access to package resources"""
  
--- 348,353 ----
***************
*** 356,372 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class WorkingSet(object):
      """A collection of active distributions on sys.path (or a similar list)"""
  
--- 378,383 ----
***************
*** 405,413 ****
          return self.by_key.get(dist.key) == dist
  
  
- 
- 
- 
      def find(self, req):
          """Find a distribution matching requirement `req`
  
--- 416,421 ----
***************
*** 509,516 ****
  
          while requirements:
              req = requirements.pop(0)   # process dependencies breadth-first
!             if req in processed:
!                 # Ignore cyclic or redundant dependencies
                  continue
              dist = best.get(req.key)
              if dist is None:
--- 517,525 ----
  
          while requirements:
              req = requirements.pop(0)   # process dependencies breadth-first
!             if req in processed or req.key == 'setuptools':
!                 # Ignore cyclic or redundant dependencies or dependencies
!                 #  on setuptools which enstaller replaces.
                  continue
              dist = best.get(req.key)
              if dist is None:
***************
*** 521,527 ****
                          env = Environment(self.entries)
                      dist = best[req.key] = env.best_match(req, self, installer)
                      if dist is None:
!                         raise DistributionNotFound(req)  # XXX put more info here
                  to_activate.append(dist)
              if dist not in req:
                  # Oops, the "best" so far conflicts with a dependency
--- 530,541 ----
                          env = Environment(self.entries)
                      dist = best[req.key] = env.best_match(req, self, installer)
                      if dist is None:
!                         raise DistributionNotFound("""
! Could not find installed package matching %r
! 
! To resolve this problem you may want to try the command: enpkg list
! This will list all installed packages.""" % req)
! 
                  to_activate.append(dist)
              if dist not in req:
                  # Oops, the "best" so far conflicts with a dependency
***************
*** 610,618 ****
          return distributions, error_info
  
  
- 
- 
- 
      def require(self, *requirements):
          """Ensure that distributions matching `requirements` are activated
  
--- 624,629 ----
***************
*** 646,663 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
  class Environment(object):
      """Searchable snapshot of distributions on a search path"""
  
!     def __init__(self, search_path=None, platform=get_supported_platform(), python=PY_MAJOR):
          """Snapshot distributions available on a search path
  
          Any distributions found on `search_path` are added to the environment.
--- 657,667 ----
  
  
  
  class Environment(object):
      """Searchable snapshot of distributions on a search path"""
  
!     def __init__(self, search_path=None, platform=get_supported_platform(),
!                  python=PY_MAJOR):
          """Snapshot distributions available on a search path
  
          Any distributions found on `search_path` are added to the environment.
***************
*** 722,728 ****
  
          if project_name not in self._cache:
              dists = self._cache[project_name] = self._distmap[project_name]
!             _sort_dists(dists)
  
          return self._cache[project_name]
  
--- 726,734 ----
  
          if project_name not in self._cache:
              dists = self._cache[project_name] = self._distmap[project_name]
!             # DMP 2009.05.12: Sort by (repo,version) so need to pass repo list.
!             #_sort_dists(dists)
!             _sort_dists(dists, getattr(self, '_repo_urls', None))
  
          return self._cache[project_name]
  
***************
*** 733,739 ****
              if dist not in dists:
                  dists.append(dist)
                  if dist.key in self._cache:
!                     _sort_dists(self._cache[dist.key])
  
  
      def best_match(self, req, working_set, installer=None):
--- 739,749 ----
              if dist not in dists:
                  dists.append(dist)
                  if dist.key in self._cache:
!                     # DMP 2009.05.12: Sort by (repo,version) so need to pass
!                     # repo list.
!                     #_sort_dists(self._cache[dist.key])
!                     _sort_dists(self._cache[dist.key], 
!                         getattr(self, '_repo_urls', None))
  
  
      def best_match(self, req, working_set, installer=None):
***************
*** 817,823 ****
  
  
  
- 
  class ResourceManager:
      """Manage resource extraction and packages"""
      extraction_path = None
--- 827,832 ----
***************
*** 889,905 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      def get_cache_path(self, archive_name, names=()):
          """Return absolute location in cache for `archive_name` and `names`
  
--- 898,903 ----
***************
*** 925,946 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      def postprocess(self, tempname, filename):
          """Perform any platform-specific postprocessing of `tempname`
  
--- 923,928 ----
***************
*** 963,987 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      def set_extraction_path(self, path):
          """Set the base path where resources will be extracted to, if needed.
  
--- 945,950 ----
***************
*** 1099,1110 ****
      return name.replace('-','_')
  
  
- 
- 
- 
- 
- 
- 
  class NullProvider:
      """Try to implement resources and metadata for arbitrary PEP 302 loaders"""
  
--- 1062,1067 ----
***************
*** 1224,1233 ****
              path, base = os.path.split(path)
  
  
- 
- 
- 
- 
  class DefaultProvider(EggProvider):
      """Provides access to package resources in the filesystem"""
  
--- 1181,1186 ----
***************
*** 1267,1274 ****
  empty_provider = EmptyProvider()
  
  
- 
- 
  class ZipProvider(EggProvider):
      """Resource support for zips and eggs"""
  
--- 1220,1225 ----
***************
*** 1412,1438 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class FileMetadata(EmptyProvider):
      """Metadata handler for standalone PKG-INFO files
  
--- 1363,1368 ----
***************
*** 1461,1479 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class PathMetadata(DefaultProvider):
      """Metadata provider for egg directories
  
--- 1391,1396 ----
***************
*** 1669,1680 ****
                          path_item,entry,metadata,precedence=DEVELOP_DIST
                      )
                  elif not only and lower.endswith('.egg'):
!                     for dist in find_distributions(os.path.join(path_item, entry)):
                          yield dist
                  elif not only and lower.endswith('.egg-link'):
                      for line in file(os.path.join(path_item, entry)):
                          if not line.strip(): continue
!                         for item in find_distributions(os.path.join(path_item,line.rstrip())):
                              yield item
                          break
  register_finder(ImpWrapper,find_on_path)
--- 1586,1600 ----
                          path_item,entry,metadata,precedence=DEVELOP_DIST
                      )
                  elif not only and lower.endswith('.egg'):
!                     for dist in find_distributions(os.path.join(path_item,
!                                                                 entry)):
                          yield dist
                  elif not only and lower.endswith('.egg-link'):
                      for line in file(os.path.join(path_item, entry)):
                          if not line.strip(): continue
!                         for item in find_distributions(
!                             os.path.join(path_item, line.rstrip())
!                             ):
                              yield item
                          break
  register_finder(ImpWrapper,find_on_path)
***************
*** 1884,1889 ****
--- 1804,1851 ----
                  parts.pop()
          parts.append(part)
      return tuple(parts)
+     
+ def compose_version_string(version_tuple):
+     """
+     Convert a tuple of strings that represents a version(output of 'parse_version')
+     back to a single version string.
+     """
+     # Iterate through the parts of the input version tuple.
+     version_parts = []
+     for part in version_tuple:
+         
+         # Try to do a string->integer conversion on the current part of the tuple.
+         try:
+             digit = int(part)
+             # If we were able to convert the part of the tuple to an integer,
+             # which removes the padded 0's, check if the last digit we extracted
+             # as part of the version was also an integer.  If it was, then we need
+             # to separate them with a '.', otherwise just add this new digit to our
+             # version_parts list.
+             try:
+                 int(version_parts[-1])
+                 version_parts.append('.')
+             except:
+                 pass
+             version_parts.append(str(digit))
+         except:
+             # If the current part of the tuple isn't a digit, then it is some kind of
+             # character tag and will be prefixed by a '*' character.  If the current
+             # part of the tuple is '*final', just skip it because this is not part of the
+             # version string itself.
+             if part != '*final':
+                 # If we can't convert the last digit that we extracted as part of the
+                 # version string to an integer, this means it is a character, so we need to
+                 # separate the current character we are dealing with from it by a '.'.
+                 # Otherwise, just add the current character to our version_parts list.
+                 try:
+                     int(version_parts[-1])
+                 except:
+                     version_parts.append('.')
+                 version_parts.append(part[1:])
+                 
+     # Convert our version_parts list to a single string and return it.
+     return ''.join(version_parts)
  
  class EntryPoint(object):
      """Object representing an advertised importable object"""
***************
*** 2005,2013 ****
  
  
  
- 
- 
- 
  class Distribution(object):
      """Wrap an actual or potential sys.path entry w/metadata"""
      def __init__(self,
--- 1967,1972 ----
***************
*** 2087,2095 ****
                  )
      version = property(version)
  
- 
- 
- 
      #@property
      def _dep_map(self):
          try:
--- 2046,2051 ----
***************
*** 2195,2217 ****
          """Return the EntryPoint object for `group`+`name`, or ``None``"""
          return self.get_entry_map(group).get(name)
  
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
  
      def insert_on(self, path, loc = None):
          """Insert self.location in path before its nearest parent directory"""
--- 2151,2179 ----
          """Return the EntryPoint object for `group`+`name`, or ``None``"""
          return self.get_entry_map(group).get(name)
  
!     def is_non_release(self):
!         """ Checks the parsed version spec of the current package and returns
!         true if it is not a release build. Non-release builds contain any
!         qualifier that is alphabetically before 'final' or contains an 'r' for
!         a specific revision number.
!         """
!         # For each part of the version, check for any development qualifier
!         for version_part in self.parsed_version:
!             
!             # If this part is an integer or the special final qualifier, skip it
!             if version_part.isdigit() or version_part == '*final-':
!                 continue
!             
!             # If the part sorts alphabetically before 'final' or specifies that
!             # this build was made from a specific revision number, this is a
!             # non-release build. Otherwise, this is a release build
!             if version_part < '*final' or version_part == '*r':
!                 return True
!             else:
!                 return False
!             
!         #Fall-back return incase the loop exits
!         return False
  
      def insert_on(self, path, loc = None):
          """Insert self.location in path before its nearest parent directory"""
***************
*** 2255,2262 ****
  
  
      def check_version_conflict(self):
!         if self.key=='setuptools':
!             return      # ignore the inevitable setuptools self-conflicts  :(
  
          nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))
          loc = normalize_path(self.location)
--- 2217,2224 ----
  
  
      def check_version_conflict(self):
!         if self.key=='enstaller':
!             return      # ignore the inevitable enstaller self-conflicts  :(
  
          nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))
          loc = normalize_path(self.location)
***************
*** 2315,2341 ****
      warn(stacklevel = level+1, *args, **kw)
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  def parse_requirements(strs):
      """Yield ``Requirement`` objects for each specification in `strs`
  
--- 2277,2282 ----
***************
*** 2397,2420 ****
          yield Requirement(project_name, specs, extras)
  
  
! def _sort_dists(dists):
!     tmp = [(dist.hashcmp,dist) for dist in dists]
!     tmp.sort()
!     dists[::-1] = [d for hc,d in tmp]
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
  
  
  
  
  
--- 2338,2382 ----
          yield Requirement(project_name, specs, extras)
  
  
! def _sort_dists(dists, urls=None):
!     """
!     DMP 2009.05.12: If a list of repo urls was provided, We want to sort the
!     dists primarily in the order of the those repositories so that we prefer
!     any matching dist from the first repository over a later dist in a later
!     repository.  Secondarily, we want them sorted by the dist's hashcmp value
!     so that they are sorted with the most recent version first.
  
+     """
+     if urls:
+         # First build a dictionary where the urls are mapped to the integer
+         # we want them to sort by.  Note that we want the integers to force
+         # sorting in the reverse order because the hashcmp values of the
+         # distributions also sort in the reverse order we really want to
+         # end up with.  (older versions end up first.)  When we copy the
+         # sorted list back into the provided dists variable, we reverse the
+         # sorting then to end up with the desired final sort order.
+         url_map = dict(zip(urls, xrange(len(urls), 0, -1)))
+ 
+         # Build a list that will sort naturally by our desired attributes,
+         # that is the repo info first and the version second.
+         tmp = []
+         for dist in dists:
+             loc = dist.location
+             for prefix in url_map:
+                 if loc.startswith(prefix):
+                     index = url_map[prefix]
+                     break
+             else:
+                 index = -1
+             tmp.append((index, dist.hashcmp, dist))
+         
+         tmp.sort()
+         dists[::-1] = [d for i,hc,d in tmp]
  
+     else:
+         tmp = [(dist.hashcmp,dist) for dist in dists]
+         tmp.sort()
+         dists[::-1] = [d for hc,d in tmp]
  
  
  
