*** ../../setuptools-0.6c9/pkg_resources.py	2008-09-24 12:10:45.000000000 -0500
--- ../pkg_resources.py	2008-12-15 14:14:32.000000000 -0600
***************
*** 24,44 ****
  from os import open as os_open
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  def get_supported_platform():
      """Return this platform's maximum compatible version.
  
--- 24,29 ----
***************
*** 61,85 ****
      return plat
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  __all__ = [
      # Basic resource access and distribution/entry point discovery
      'require', 'run_script', 'get_provider',  'get_distribution',
--- 46,51 ----
***************
*** 311,331 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class IResourceProvider(IMetadataProvider):
      """An object that provides access to package resources"""
  
--- 277,282 ----
***************
*** 356,372 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class WorkingSet(object):
      """A collection of active distributions on sys.path (or a similar list)"""
  
--- 307,312 ----
***************
*** 405,413 ****
          return self.by_key.get(dist.key) == dist
  
  
- 
- 
- 
      def find(self, req):
          """Find a distribution matching requirement `req`
  
--- 345,350 ----
***************
*** 509,516 ****
  
          while requirements:
              req = requirements.pop(0)   # process dependencies breadth-first
!             if req in processed:
!                 # Ignore cyclic or redundant dependencies
                  continue
              dist = best.get(req.key)
              if dist is None:
--- 446,454 ----
  
          while requirements:
              req = requirements.pop(0)   # process dependencies breadth-first
!             if req in processed or req.key == 'setuptools':
!                 # Ignore cyclic or redundant dependencies or dependencies
!                 #  on setuptools which enstaller replaces.
                  continue
              dist = best.get(req.key)
              if dist is None:
***************
*** 521,527 ****
                          env = Environment(self.entries)
                      dist = best[req.key] = env.best_match(req, self, installer)
                      if dist is None:
!                         raise DistributionNotFound(req)  # XXX put more info here
                  to_activate.append(dist)
              if dist not in req:
                  # Oops, the "best" so far conflicts with a dependency
--- 459,470 ----
                          env = Environment(self.entries)
                      dist = best[req.key] = env.best_match(req, self, installer)
                      if dist is None:
!                         raise DistributionNotFound("""
! Could not find installed package matching %r
! 
! To resolve this problem you may want to try the command: enpkg list
! This will list all installed packages.""" % req)
! 
                  to_activate.append(dist)
              if dist not in req:
                  # Oops, the "best" so far conflicts with a dependency
***************
*** 610,618 ****
          return distributions, error_info
  
  
- 
- 
- 
      def require(self, *requirements):
          """Ensure that distributions matching `requirements` are activated
  
--- 553,558 ----
***************
*** 646,663 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
  class Environment(object):
      """Searchable snapshot of distributions on a search path"""
  
!     def __init__(self, search_path=None, platform=get_supported_platform(), python=PY_MAJOR):
          """Snapshot distributions available on a search path
  
          Any distributions found on `search_path` are added to the environment.
--- 586,596 ----
  
  
  
  class Environment(object):
      """Searchable snapshot of distributions on a search path"""
  
!     def __init__(self, search_path=None, platform=get_supported_platform(),
!                  python=PY_MAJOR):
          """Snapshot distributions available on a search path
  
          Any distributions found on `search_path` are added to the environment.
***************
*** 817,823 ****
  
  
  
- 
  class ResourceManager:
      """Manage resource extraction and packages"""
      extraction_path = None
--- 750,755 ----
***************
*** 889,905 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      def get_cache_path(self, archive_name, names=()):
          """Return absolute location in cache for `archive_name` and `names`
  
--- 821,826 ----
***************
*** 925,946 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      def postprocess(self, tempname, filename):
          """Perform any platform-specific postprocessing of `tempname`
  
--- 846,851 ----
***************
*** 963,987 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      def set_extraction_path(self, path):
          """Set the base path where resources will be extracted to, if needed.
  
--- 868,873 ----
***************
*** 1099,1110 ****
      return name.replace('-','_')
  
  
- 
- 
- 
- 
- 
- 
  class NullProvider:
      """Try to implement resources and metadata for arbitrary PEP 302 loaders"""
  
--- 985,990 ----
***************
*** 1224,1233 ****
              path, base = os.path.split(path)
  
  
- 
- 
- 
- 
  class DefaultProvider(EggProvider):
      """Provides access to package resources in the filesystem"""
  
--- 1104,1109 ----
***************
*** 1267,1274 ****
  empty_provider = EmptyProvider()
  
  
- 
- 
  class ZipProvider(EggProvider):
      """Resource support for zips and eggs"""
  
--- 1143,1148 ----
***************
*** 1412,1438 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class FileMetadata(EmptyProvider):
      """Metadata handler for standalone PKG-INFO files
  
--- 1286,1291 ----
***************
*** 1461,1479 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class PathMetadata(DefaultProvider):
      """Metadata provider for egg directories
  
--- 1314,1319 ----
***************
*** 1669,1680 ****
                          path_item,entry,metadata,precedence=DEVELOP_DIST
                      )
                  elif not only and lower.endswith('.egg'):
!                     for dist in find_distributions(os.path.join(path_item, entry)):
                          yield dist
                  elif not only and lower.endswith('.egg-link'):
                      for line in file(os.path.join(path_item, entry)):
                          if not line.strip(): continue
!                         for item in find_distributions(os.path.join(path_item,line.rstrip())):
                              yield item
                          break
  register_finder(ImpWrapper,find_on_path)
--- 1509,1523 ----
                          path_item,entry,metadata,precedence=DEVELOP_DIST
                      )
                  elif not only and lower.endswith('.egg'):
!                     for dist in find_distributions(os.path.join(path_item,
!                                                                 entry)):
                          yield dist
                  elif not only and lower.endswith('.egg-link'):
                      for line in file(os.path.join(path_item, entry)):
                          if not line.strip(): continue
!                         for item in find_distributions(
!                             os.path.join(path_item, line.rstrip())
!                             ):
                              yield item
                          break
  register_finder(ImpWrapper,find_on_path)
***************
*** 2005,2013 ****
  
  
  
- 
- 
- 
  class Distribution(object):
      """Wrap an actual or potential sys.path entry w/metadata"""
      def __init__(self,
--- 1848,1853 ----
***************
*** 2087,2095 ****
                  )
      version = property(version)
  
- 
- 
- 
      #@property
      def _dep_map(self):
          try:
--- 1927,1932 ----
***************
*** 2195,2217 ****
          """Return the EntryPoint object for `group`+`name`, or ``None``"""
          return self.get_entry_map(group).get(name)
  
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
  
      def insert_on(self, path, loc = None):
          """Insert self.location in path before its nearest parent directory"""
--- 2032,2060 ----
          """Return the EntryPoint object for `group`+`name`, or ``None``"""
          return self.get_entry_map(group).get(name)
  
!     def is_non_release(self):
!         """ Checks the parsed version spec of the current package and returns
!         true if it is not a release build. Non-release builds contain any
!         qualifier that is alphabetically before 'final' or contains an 'r' for
!         a specific revision number.
!         """
!         # For each part of the version, check for any development qualifier
!         for version_part in self.parsed_version:
!             
!             # If this part is an integer or the special final qualifier, skip it
!             if version_part.isdigit() or version_part == '*final-':
!                 continue
!             
!             # If the part sorts alphabetically before 'final' or specifies that
!             # this build was made from a specific revision number, this is a
!             # non-release build. Otherwise, this is a release build
!             if version_part < '*final' or version_part == '*r':
!                 return True
!             else:
!                 return False
!             
!         #Fall-back return incase the loop exits
!         return False
  
      def insert_on(self, path, loc = None):
          """Insert self.location in path before its nearest parent directory"""
***************
*** 2255,2262 ****
  
  
      def check_version_conflict(self):
!         if self.key=='setuptools':
!             return      # ignore the inevitable setuptools self-conflicts  :(
  
          nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))
          loc = normalize_path(self.location)
--- 2098,2105 ----
  
  
      def check_version_conflict(self):
!         if self.key=='enstaller':
!             return      # ignore the inevitable enstaller self-conflicts  :(
  
          nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))
          loc = normalize_path(self.location)
***************
*** 2315,2341 ****
      warn(stacklevel = level+1, *args, **kw)
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  def parse_requirements(strs):
      """Yield ``Requirement`` objects for each specification in `strs`
  
--- 2158,2163 ----
***************
*** 2404,2423 ****
  
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  class Requirement:
      def __init__(self, project_name, specs, extras):
          """DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!"""
--- 2226,2231 ----
