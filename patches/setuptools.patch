Only in ../../Enstaller/setuptools: archive_util.pyc
Only in ../../Enstaller/setuptools/command: alias.pyc
Only in ../../Enstaller/setuptools/command: bdist_egg.pyc
Only in ../../Enstaller/setuptools/command: bdist_rpm.pyc
Only in ../../Enstaller/setuptools/command: bdist_wininst.pyc
Only in ../../Enstaller/setuptools/command: build_ext.pyc
Only in ../../Enstaller/setuptools/command: build_py.pyc
diff -cr ../../setuptools-0.6c9/setuptools/command/develop.py ../../Enstaller/setuptools/command/develop.py
*** ../../setuptools-0.6c9/setuptools/command/develop.py	2008-02-15 11:29:24.000000000 -0600
--- ../../Enstaller/setuptools/command/develop.py	2008-11-10 14:07:42.000000000 -0600
***************
*** 22,27 ****
--- 22,28 ----
      def run(self):
          if self.uninstall:
              self.multi_version = True
+             self._run_pre_uninstall(self.distribution.location)
              self.uninstall_link()
          else:
              self.install_for_development()
***************
*** 35,44 ****
          self.always_copy_from = '.'   # always copy eggs installed in curdir
  
  
- 
- 
- 
- 
      def finalize_options(self):
          ei = self.get_finalized_command("egg_info")
          if ei.broken_egg_info:
--- 36,41 ----
Only in ../../Enstaller/setuptools/command: develop.py~
Only in ../../Enstaller/setuptools/command: develop.pyc
diff -cr ../../setuptools-0.6c9/setuptools/command/easy_install.py ../../Enstaller/setuptools/command/easy_install.py
*** ../../setuptools-0.6c9/setuptools/command/easy_install.py	2008-09-24 12:22:12.000000000 -0500
--- ../../Enstaller/setuptools/command/easy_install.py	2008-11-21 18:10:59.000000000 -0600
***************
*** 9,16 ****
  
  __ http://peak.telecommunity.com/DevCenter/EasyInstall
  """
! import sys, os.path, zipimport, shutil, tempfile, zipfile, re, stat, random
  from glob import glob
  from setuptools import Command
  from setuptools.sandbox import run_setup
  from distutils import log, dir_util
--- 9,24 ----
  
  __ http://peak.telecommunity.com/DevCenter/EasyInstall
  """
! 
! # Patched with easy_install.patch and prefer_released.patch from Enthought
! #  starting with setuptools 0.6c9
! 
! import sys, os, os.path, shutil, zipimport, tempfile, re, stat, random
! import zipfile
! from os import path
  from glob import glob
+ from subprocess import call
+ 
  from setuptools import Command
  from setuptools.sandbox import run_setup
  from distutils import log, dir_util
***************
*** 39,44 ****
--- 47,57 ----
          os.path.normpath(os.path.normcase(p2))
      )
  
+ def execute_script(script):
+     retcode = call(["python", script])
+     if retcode != 0:
+         raise RuntimeError, "Return code of %d" % retcode
+ 
  class easy_install(Command):
      """Manage a download/build/install process"""
      description = "Find/get/install Python packages"
***************
*** 49,54 ****
--- 62,68 ----
          ("zip-ok", "z", "install package as a zipfile"),
          ("multi-version", "m", "make apps have to require() a version"),
          ("upgrade", "U", "force upgrade (searches PyPI for latest versions)"),
+         ("remove", "r", "remove (uninstall) package"),
          ("install-dir=", "d", "install package to DIR"),
          ("script-dir=", "s", "install scripts to DIR"),
          ("exclude-scripts", "x", "Don't install scripts"),
***************
*** 69,81 ****
          ('site-dirs=','S',"list of directories where .pth files work"),
          ('editable', 'e', "Install specified packages in editable form"),
          ('no-deps', 'N', "don't install dependencies"),
          ('allow-hosts=', 'H', "pattern(s) that hostnames must match"),
          ('local-snapshots-ok', 'l', "allow building eggs from local checkouts"),
      ]
      boolean_options = [
          'zip-ok', 'multi-version', 'exclude-scripts', 'upgrade', 'always-copy',
          'delete-conflicting', 'ignore-conflicts-at-my-risk', 'editable',
!         'no-deps', 'local-snapshots-ok',
      ]
      negative_opt = {'always-unzip': 'zip-ok'}
      create_index = PackageIndex
--- 83,97 ----
          ('site-dirs=','S',"list of directories where .pth files work"),
          ('editable', 'e', "Install specified packages in editable form"),
          ('no-deps', 'N', "don't install dependencies"),
+         ('allow-dev', 'D', "allow non-release packages to be installed"),
          ('allow-hosts=', 'H', "pattern(s) that hostnames must match"),
          ('local-snapshots-ok', 'l', "allow building eggs from local checkouts"),
+         ('proxy=', 'p', "Add proxy for downloads")
      ]
      boolean_options = [
          'zip-ok', 'multi-version', 'exclude-scripts', 'upgrade', 'always-copy',
          'delete-conflicting', 'ignore-conflicts-at-my-risk', 'editable',
!         'no-deps', 'local-snapshots-ok', 'allow-dev'
      ]
      negative_opt = {'always-unzip': 'zip-ok'}
      create_index = PackageIndex
***************
*** 88,95 ****
--- 104,114 ----
          self.build_directory = None
          self.args = None
          self.optimize = self.record = None
+         self.remove = None
+         self.proxy = None
          self.upgrade = self.always_copy = self.multi_version = None
          self.editable = self.no_deps = self.allow_hosts = None
+         self.allow_dev = None
          self.root = self.prefix = self.no_report = None
  
          # Options not specifiable via command line
***************
*** 203,227 ****
  
          self.outputs = []
  
      def run(self):
          if self.verbose<>self.distribution.verbose:
              log.set_verbosity(self.verbose)
          try:
!             for spec in self.args:
!                 self.easy_install(spec, not self.no_deps)
!             if self.record:
!                 outputs = self.outputs
!                 if self.root:               # strip any package prefix
!                     root_len = len(self.root)
!                     for counter in xrange(len(outputs)):
!                         outputs[counter] = outputs[counter][root_len:]
!                 from distutils import file_util
!                 self.execute(
!                     file_util.write_file, (self.record, outputs),
!                     "writing list of installed files to '%s'" %
!                     self.record
!                 )
!             self.warn_deprecated_options()
          finally:
              log.set_verbosity(self.distribution.verbose)
  
--- 222,262 ----
  
          self.outputs = []
  
+         # Add a list for files installed by the current package only.
+         self.outputs_this_package = []
+ 
+         if self.proxy is not None:
+             from enstaller.proxy.api import setup_proxy
+             installed = setup_proxy(self.proxy)
+             print "Yes...", installed
+             print self.proxy
+ 
      def run(self):
          if self.verbose<>self.distribution.verbose:
              log.set_verbosity(self.verbose)
          try:
!             if self.remove:
!                 self.uninstall(self.args)
!             else:
!                 for spec in self.args:
!                     self.easy_install(spec, not self.no_deps)
! 
!                 if self.record:
!                     # Get the list of files installed
!                     outputs = self.outputs
! 
!                     # Strip any package prefix
!                     if self.root:
!                         root_len = len(self.root)
!                         for counter in xrange(len(outputs)):
!                             outputs[counter] = outputs[counter][root_len:]
!                     from distutils import file_util
!                     self.execute(
!                         file_util.write_file, (self.record, outputs),
!                         "writing list of installed files to '%s'" %
!                         self.record
!                     )
!                 self.warn_deprecated_options()
          finally:
              log.set_verbosity(self.distribution.verbose)
  
***************
*** 249,254 ****
--- 284,297 ----
          instdir = normalize_path(self.install_dir)
          pth_file = os.path.join(instdir,'easy-install.pth')
  
+         try:
+             os.makedirs(instdir)
+         except OSError:
+             # Oh well -- hopefully this error simply means that it
+             #  is already there.  If not the subsequent write test
+             #  will identify the problem.
+             pass
+ 
          # Is it a configured, PYTHONPATH, implicit, or explicit site dir?
          is_site_dir = instdir in self.all_site_dirs
  
***************
*** 268,274 ****
  
          if not is_site_dir and not self.multi_version:
              # Can't install non-multi to non-site dir
!             raise DistutilsError(self.no_default_version_msg())
  
          if is_site_dir:
              if self.pth_file is None:
--- 311,317 ----
  
          if not is_site_dir and not self.multi_version:
              # Can't install non-multi to non-site dir
!             log.warn(self.no_default_version_msg())
  
          if is_site_dir:
              if self.pth_file is None:
***************
*** 382,389 ****
--- 425,434 ----
              for base, dirs, files in os.walk(path):
                  for filename in files:
                      self.outputs.append(os.path.join(base,filename))
+                     self.outputs_this_package.append(os.path.join(base,filename))
          else:
              self.outputs.append(path)
+             self.outputs_this_package.append(path)
  
      def not_editable(self, spec):
          if self.editable:
***************
*** 402,411 ****
--- 447,750 ----
                  "%r already exists in %s; can't do a checkout there" %
                  (spec.key, self.build_directory)
              )
+     
+     def get_deps(self):
+         """Check for back dependencies. The idea is that if a package is being
+         uninstalled and a dependency is also being uninstalled, this will help
+         check to see if any other packages will be broken by the dependency. It
+         returns a dictionary in the format
+         {dependency: {project1: dependency_version}, {project2: dependency_version}}
+         
+         """
+         
+         # Get the set of installed packages
+         projects = WorkingSet()
+         
+         # Instantiate dictionary of project requirements
+         reqdict = {}
+         
+         # Instantiate back-dependency dictionary. The ONLY items in this
+         # will be projects that are depended upon by something else.
+         low_dep_dict = {}
+         
+         # Create dictionary of each installed project and related dependencies
+         for project in projects:
+             
+             # list of requirements for each project
+             try:
+                 reqs = require(project.project_name)
+             except DistributionNotFound:
+                 continue
+             reqdict[project] = reqs
+         
+         # Create the dictionary of packages being depended on.
+         for key, value in reqdict.iteritems():
+             for item in value:
+                 
+                 # This keeps out entries that have only themselves in the 
+                 # dependency list
+                 if item.project_name == key.project_name:
+                     continue
+                
+                 # spec becomes a list of tuples of version numbers and 
+                 # operators, eg [(">=", "2.0"), ("<=", 3.0")]
+                 spec = value[0].requires()[0].specs
+                 
+                 # version_list will become a concatenated list of versions, eg
+                 # ['>=2.0', '<=3.0']
+                 version_list = []
+                 if not spec:
+                     version_list.append('(any version)')
+                 for version in spec:
+                     version_list.append(''.join(version))
+                 version_string = ','.join(version_list)
+                 if low_dep_dict.has_key(item.project_name):
+                     low_dep_dict[item.project_name][key.project_name] = version_string
+                 else:
+                     low_dep_dict[item.project_name] = {key.project_name: version_string}
+         
+         # low_dep_dict is in the form
+         # {dependency: {project1: dependency_version}, {project2: dependency_version}}
+         return low_dep_dict
+ 
+     def check_deps(self, current_dep, user_spec, all):
+         """Takes in the current dependency being checked, the project specified
+         for removal, and the set of all packages that something depends upon.
+         Returns True or False based on user confirmation
+         """
+         
+         if current_dep not in all.keys():
+             print "Nothing else depends on %s." % current_dep
+         
+         # Check to see if a dependency is is only required by the package
+         # specified for removal.
+         elif len(all[current_dep]) == 1 and user_spec in all[current_dep].keys():
+             print "Only %s seems to require %s." % (user_spec, current_dep)
+         else:
+             
+             # Fetch dictionary of projects that require current_dep
+             depends_on_dep = all[current_dep]
+             
+             # Print list of projects that need current_dep
+             for project in depends_on_dep:
+                 print "%s %s is needed by %s." % \
+                 (current_dep, depends_on_dep[project], project)
+         
+         choice = ''
+         while 1:
+             if choice.lower() == 'n':
+                 return False
+             elif choice.lower() == 'y':
+                 return True
+             else:
+                 choice = raw_input("Remove %s? [Y/N] " % current_dep)
  
+     def _run_post_install(self, installed_egg_path):
+         """
+         run any post-install scripts in the newly-installed egg defined by the
+         package passed in (the package is either a string defining a package
+         name or package requirement spec, or a package object containing info
+         about the package downloaded (not just installed)).
+         """
+         tmp_unpack_dir = ""
  
+         #
+         # if the egg installed is a dir, simply check the EGG-INFO subdir
+         # for a post_install.py script and run it, otherwise, unzip it to
+         # a temp location and do the same thing
+         #
+         if(path.isdir(installed_egg_path)):
+             egg_dir = installed_egg_path
+         else:
+             tmp_unpack_dir = tempfile.mkdtemp(prefix="easy_install-")
+             egg_dir = path.join(tmp_unpack_dir,
+                                 path.basename(installed_egg_path))
+             unpack_archive(installed_egg_path, egg_dir)
+         #
+         # check for post_install.py and run if present
+         #
+         pi_script = path.join(egg_dir, "EGG-INFO", "post_install.py")
+         if path.exists(pi_script):
+             try:
+                 execute_script(pi_script)
+             except Exception, err :
+                 self.log("Error: problem running post-install script %s: %s\n" \
+                           % (pi_script, err) )
+ 
+         #
+         # cleanup if a temp extraction was done
+         #
+         if(tmp_unpack_dir != ""):
+             self._rm_rf(tmp_unpack_dir)
  
+     def _run_pre_uninstall(self, installed_egg_path):
+         """
+         run any pre-uninstall scripts in the installed egg defined by the
+         package passed in (the package is either a string defining a package
+         name or package requirement spec, or a package object containing info
+         about the package.
+         """
+         tmp_unpack_dir = ""
  
+         #
+         # if the egg installed is a dir, simply check the EGG-INFO subdir
+         # for a post_install.py script and run it, otherwise, unzip it to
+         # a temp location and do the same thing
+         #
+         if path.isdir(installed_egg_path):
+             egg_dir = installed_egg_path
+             
+         else:
+             tmp_unpack_dir = tempfile.mkdtemp(prefix="easy_install-")
+             egg_dir = path.join(tmp_unpack_dir,
+                                 path.basename(installed_egg_path))
+             unpack_archive(installed_egg_path, egg_dir)
+         #
+         # check for uninstall.py and run if present
+         #
+         uninstall_script = path.join(egg_dir, "EGG-INFO", "uninstall.py")
+         if path.exists(uninstall_script):
+             try:
+                 execute_script(uinstall_script)
+             except Exception, err :
+                 self.log("Error: problem running uninstall script %s: %s\n" \
+                          % (uninstall_script, err))
+ 
+         #
+         # cleanup if a temp extraction was done
+         #
+         if tmp_unpack_dir != "":
+             self._rm_rf(tmp_unpack_dir)
+ 
+     
+     def uninstall(self, specs):
+         """ Uninstall function to remove all files associated with an egg,
+         including scripts generated.  Also does a back-check of dependencies
+         on the package(s) being uninstalled and prompts the user for
+         uninstalling unnecessary dependencies that can be removed
+         and warns if uninstalling a package could break another installed package.
+         """
+         try:
+             # If no dependencies, then just get the distributions from
+             #  the requirement specifications and remove them.
+             if self.no_deps:
+                 for spec in specs:
+                     try:
+                         dist = working_set.find(Requirement.parse(spec))
+                     except:
+                         raise DistributionNotFound
+                     self._remove_dist(dist)
+             return
+                 
+             all_deps = self.get_deps()
+                     
+             for spec in specs:
+                 pkgs = require(spec)
+                 
+                 # If the package found has dependencies, prompt the user if they
+                 # want the dependencies to be uninstalled as well.
+                 if len(pkgs) > 1:
+                     for dep in pkgs[1:]:
+                         if self.check_deps(dep.project_name, spec, all_deps):
+                             self._remove_dist(dep)
+                             
+                 # Finally, check if user-specified package can be safely
+                 # removed.
+                 if self.check_deps(pkgs[0].project_name, spec, all_deps):
+                     self._remove_dist(pkgs[0])
+                         
+         except DistributionNotFound:
+                 log.info("Could not find suitable package for: %s" % spec)
+             
+             
+     def _remove_dist(self, dist):
+         """ Module to remove Distribution objects.
+         """
+         pkg_path = dist.location
+         log.info("Removing %s..." % pkg_path)
+         self._run_pre_uninstall(pkg_path)
+         self._remove_package_file(pkg_path)
+         
+         
+     def _remove_package_file(self, package_filepath):
+         """
+         Finds the easy_install.pth file and removes the line containing the
+         package_filepath, if present, then removes the egg file or dir.
+         """
+         retcode = 0
+         package_path = path.abspath(package_filepath)
+         (package_dir, package_fullname) = path.split(package_path)
+ 
+         # Read the file (if it exists), find the matching line and write the
+         # file again without the matching line.
+         pth_file = path.join(package_dir, "easy-install.pth")
+         if path.exists(pth_file):
+             fh = open(pth_file, "r")
+             lines = fh.readlines()
+             fh.close()
+ 
+             newlines = []
+             for line in lines:
+                 # On Windows, a leading ./ is often found and is safe to remove
+                 # for comparisons...also, strip off the newline.
+                 chkline = line.strip()
+                 if chkline.startswith("./") :
+                     chkline = chkline[2:]
+                 if chkline != package_fullname:
+                     newlines.append(line)
+                     
+             else:
+                 fh = open(pth_file, "wu")
+                 for line in newlines:
+                     fh.write(line)
+                 fh.close()
+                 
+         # Check for the installed_files.log file in the EGG-INFO of the
+         #   egg and remove all files listed in it.
+         #   This check will look inside zip-safe and non-zip-safe eggs.
+         files_file_path = path.join(package_path, 'EGG-INFO', 'installed_files.log')
+         if path.isdir(package_path):
+             if path.exists(files_file_path):
+                 fh = open(files_file_path, "r")
+                 for filename in fh.readlines():
+                     retcode = self._rm_rf(filename.strip()) or retcode
+                 fh.close()
+                 retcode = self._rm_rf(files_file_path) or retcode
+         else:
+             egg_file = zipfile.ZipFile(package_path, "r")
+             installed_files = []
+             for filename in egg_file.namelist():
+                 if filename.endswith('installed_files.log'):
+                     log = egg_file.read(filename)
+                     installed_files = log.splitlines()
+                     break;
+             egg_file.close()
+             for file in installed_files:
+                 retcode = self._rm_rf(file) or retcode
+             
+         # If it can't find the .files file, just try to remove the 
+         # directory or egg file.
+         retcode = self._rm_rf(package_path) or retcode
+         
+         return retcode
+ 
+     def _rm_rf(self, file_or_dir):
+         """
+         Removes the file or directory, returns 0 on success, 1 on failure.
+         """
+         retcode = 0
+         try:
+             if path.exists(file_or_dir):
+                 if path.isdir(file_or_dir):
+                     shutil.rmtree(file_or_dir)
+                 else:
+                     os.remove(file_or_dir)
+ 
+         except (IOError, OSError), err :
+             self.log("Error: could not remove %s: %s\n" % (file_or_dir, err))
+             retcode = 1
+ 
+         return retcode
  
  
      def easy_install(self, spec, deps=False):
***************
*** 430,436 ****
  
              self.check_editable(spec)
              dist = self.package_index.fetch_distribution(
!                 spec, tmpdir, self.upgrade, self.editable, not self.always_copy
              )
  
              if dist is None:
--- 769,776 ----
  
              self.check_editable(spec)
              dist = self.package_index.fetch_distribution(
!                 spec, tmpdir, self.upgrade, self.editable,
!                 not self.always_copy, not self.allow_dev
              )
  
              if dist is None:
***************
*** 486,493 ****
                      return dist
  
  
  
! 
  
  
      def process_distribution(self, requirement, dist, deps=True, *info):
--- 826,889 ----
                      return dist
  
  
+     def add_installed_files_list(self):
+         """ Adds all of the installed files to the EGG-INFO folder of the
+         installed package, in the file 'installed_files.log'.
+         """
+         # Get the list of files installed, give error if none are passed
+         outputs = self.outputs_this_package
+         if len(outputs) == 0:
+             log.warn('No files installed.')
+             return
+         
+         # Check for either a zipped egg or an egg directory
+         egg_zip = None
+         egg_path = ''
+         for file in outputs:
+             
+             # If an EGG-INFO path is found, save the .egg path
+             if len(file.split('EGG-INFO')) > 1:
+                 egg_path = file.split('EGG-INFO')[0]
+                 break
+                 
+             # If a .egg is found, open the egg and save its path
+             if file.endswith('.egg'):
+                 egg_zip = zipfile.ZipFile(file, 'a')
+                 egg_path = os.path.split(file)[0]
+                 break
  
!         # If nothing was found, return
!         if egg_path == '':
!             return
!         
!         # Strip any package prefixes
!         if self.root:
!             root_len = len(self.root)
!             for counter in xrange(len(outputs)):
!                 outputs[counter] = outputs[counter][root_len:]
!         
!         # If egg was not zip-safe, set path to 'EGG-INFO' dir
!         if egg_zip is None:
!             log_path = os.path.join(egg_path, 'EGG-INFO',
!                                     'installed_files.log')
!         # Else, set path to the dir that the .egg file is in
!         else:
!             log_path = os.path.join(egg_path, 'installed_files.log')
!         
!         # Create the file in the path set above
!         file = open(log_path, 'w')
! 
!         # For each installed file, write then on a new line in the log
!         for installed_file in outputs:
!             file.write(installed_file + '\n')
!         file.close()
!         
!         # If .egg file was found, put the log file in the egg, then
!         # remove the file from the directory the egg is in
!         if egg_zip is not None:
!             egg_zip.write(log_path, 'EGG-INFO/installed_files.log')
!             egg_zip.close()
!             os.remove(log_path)
  
  
      def process_distribution(self, requirement, dist, deps=True, *info):
***************
*** 496,501 ****
--- 892,902 ----
          self.local_index.add(dist)
          self.install_egg_scripts(dist)
          self.installed_projects[dist.key] = dist
+ 
+         # Add the log of all the installed files to EGG-INFO
+         self.add_installed_files_list()
+         self.outputs_this_package = []
+         
          log.info(self.installation_report(requirement, dist, *info))
          if dist.has_metadata('dependency_links.txt'):
              self.package_index.add_find_links(
***************
*** 513,518 ****
--- 914,923 ----
              requirement = Requirement(
                  distreq.project_name, distreq.specs, requirement.extras
              )
+ 
+         # Run post-install scripts
+         self._run_post_install(dist.location)
+             
          log.info("Processing dependencies for %s", requirement)
          try:
              distros = WorkingSet([]).resolve(
***************
*** 968,977 ****
  
              self.pth_file.save()
  
!             if dist.key=='setuptools':
!                 # Ensure that setuptools itself never becomes unavailable!
                  # XXX should this check for latest version?
!                 filename = os.path.join(self.install_dir,'setuptools.pth')
                  if os.path.islink(filename): os.unlink(filename)
                  f = open(filename, 'wt')
                  f.write(self.pth_file.make_relative(dist.location)+'\n')
--- 1373,1382 ----
  
              self.pth_file.save()
  
!             if dist.key=='enstaller':
!                 # Ensure that enstaller itself never becomes unavailable!
                  # XXX should this check for latest version?
!                 filename = os.path.join(self.install_dir,'enstaller.pth')
                  if os.path.islink(filename): os.unlink(filename)
                  f = open(filename, 'wt')
                  f.write(self.pth_file.make_relative(dist.location)+'\n')
***************
*** 1018,1028 ****
  
  
  
- 
- 
- 
- 
- 
      def no_default_version_msg(self):
          return """bad install directory or PYTHONPATH
  
--- 1423,1428 ----
***************
*** 1051,1069 ****
  
    http://peak.telecommunity.com/EasyInstall.html#custom-installation-locations
  
! Please make the appropriate changes for your system and try again.""" % (
          self.install_dir, os.environ.get('PYTHONPATH','')
      )
  
  
- 
- 
- 
- 
- 
- 
- 
- 
      def install_site_py(self):
          """Make sure there's a site.py in the target dir, if needed"""
  
--- 1451,1461 ----
  
    http://peak.telecommunity.com/EasyInstall.html#custom-installation-locations
  
! Proceeding to install.  Please remember that unless you make one of these changes you will not be able to run the installed code.""" % (
          self.install_dir, os.environ.get('PYTHONPATH','')
      )
  
  
      def install_site_py(self):
          """Make sure there's a site.py in the target dir, if needed"""
  
***************
*** 1071,1077 ****
              return  # already did it, or don't need to
  
          sitepy = os.path.join(self.install_dir, "site.py")
!         source = resource_string(Requirement.parse("setuptools"), "site.py")
          current = ""
  
          if os.path.exists(sitepy):
--- 1463,1469 ----
              return  # already did it, or don't need to
  
          sitepy = os.path.join(self.install_dir, "site.py")
!         source = resource_string(Requirement.parse("enstaller"), "site.py")
          current = ""
  
          if os.path.exists(sitepy):
***************
*** 1079,1085 ****
              current = open(sitepy,'rb').read()
              if not current.startswith('def __boot():'):
                  raise DistutilsError(
!                     "%s is not a setuptools-generated site.py; please"
                      " remove it." % sitepy
                  )
  
--- 1471,1477 ----
              current = open(sitepy,'rb').read()
              if not current.startswith('def __boot():'):
                  raise DistutilsError(
!                     "%s is not an enstaller-generated site.py; please"
                      " remove it." % sitepy
                  )
  
***************
*** 1095,1110 ****
          self.sitepy_installed = True
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
      INSTALL_SCHEMES = dict(
          posix = dict(
              install_dir = '$base/lib/python$py_version_short/site-packages',
--- 1487,1492 ----
***************
*** 1138,1151 ****
                      val = os.path.expanduser(val)
                  setattr(self, attr, val)
  
- 
- 
- 
- 
- 
- 
- 
- 
  def get_site_dirs():
      # return a list of 'site' dirs
      sitedirs = filter(None,os.environ.get('PYTHONPATH','').split(os.pathsep))
--- 1520,1525 ----
***************
*** 1208,1214 ****
              if not name.endswith('.pth'):
                  # We only care about the .pth files
                  continue
!             if name in ('easy-install.pth','setuptools.pth'):
                  # Ignore .pth files that we control
                  continue
  
--- 1582,1588 ----
              if not name.endswith('.pth'):
                  # We only care about the .pth files
                  continue
!             if name in ('easy-install.pth','enstaller.pth'):
                  # Ignore .pth files that we control
                  continue
  
***************
*** 1262,1274 ****
      finally:
          f.close()
  
- 
- 
- 
- 
- 
- 
- 
  def get_exe_prefixes(exe_filename):
      """Get exe->egg path translations for a given .exe file"""
  
--- 1636,1641 ----
***************
*** 1362,1370 ****
              data = (
                  "import sys; sys.__plen = len(sys.path)\n"
                  "%s\n"
!                 "import sys; new=sys.path[sys.__plen:];"
                  " del sys.path[sys.__plen:];"
!                 " p=getattr(sys,'__egginsert',0); sys.path[p:p]=new;"
                  " sys.__egginsert = p+len(new)\n"
              ) % data
  
--- 1729,1737 ----
              data = (
                  "import sys; sys.__plen = len(sys.path)\n"
                  "%s\n"
!                 "import sys, os; new=sys.path[sys.__plen:];"
                  " del sys.path[sys.__plen:];"
!                 " p=getattr(sys,'__egginsert',len(os.environ.get('PYTHONPATH','').split(os.pathsep))); sys.path[p:p]=new;"
                  " sys.__egginsert = p+len(new)\n"
              ) % data
  
***************
*** 1508,1520 ****
      return ''.join(result)
  
  
- 
- 
- 
- 
- 
- 
- 
  def is_python_script(script_text, filename):
      """Is this text, as a whole, a Python script? (as opposed to shell/bat/etc.
      """
--- 1875,1880 ----
***************
*** 1633,1639 ****
          onerror(os.rmdir, path, sys.exc_info())
  
  def bootstrap():
!     # This function is called when setuptools*.egg is run using /bin/sh
      import setuptools; argv0 = os.path.dirname(setuptools.__path__[0])
      sys.argv[0] = argv0; sys.argv.append(argv0); main()
  
--- 1993,1999 ----
          onerror(os.rmdir, path, sys.exc_info())
  
  def bootstrap():
!     # This function is called when enstaller*.egg is run using /bin/sh
      import setuptools; argv0 = os.path.dirname(setuptools.__path__[0])
      sys.argv[0] = argv0; sys.argv.append(argv0); main()
  
***************
*** 1675,1681 ****
              distclass=DistributionWithoutHelpCommands, **kw
          )
      )
- 
- 
- 
- 
--- 2035,2037 ----
Only in ../../Enstaller/setuptools/command: easy_install.py~
Only in ../../Enstaller/setuptools/command: easy_install.pyc
Only in ../../Enstaller/setuptools/command: easy_install.py.orig
Only in ../../Enstaller/setuptools/command: easy_install.py.rej
Only in ../../Enstaller/setuptools/command: egg_info.pyc
Only in ../../Enstaller/setuptools/command: __init__.pyc
Only in ../../Enstaller/setuptools/command: install_egg_info.pyc
Only in ../../Enstaller/setuptools/command: install_lib.pyc
Only in ../../Enstaller/setuptools/command: install.pyc
Only in ../../Enstaller/setuptools/command: install_scripts.pyc
Only in ../../Enstaller/setuptools/command: register.pyc
Only in ../../Enstaller/setuptools/command: rotate.pyc
Only in ../../Enstaller/setuptools/command: saveopts.pyc
Only in ../../Enstaller/setuptools/command: sdist.pyc
Only in ../../Enstaller/setuptools/command: setopt.pyc
Only in ../../Enstaller/setuptools/command: .svn
Only in ../../Enstaller/setuptools/command: test.pyc
Only in ../../Enstaller/setuptools/command: upload.pyc
Only in ../../Enstaller/setuptools: depends.pyc
Only in ../../Enstaller/setuptools: dist.pyc
Only in ../../Enstaller/setuptools: extension.pyc
diff -cr ../../setuptools-0.6c9/setuptools/__init__.py ../../Enstaller/setuptools/__init__.py
*** ../../setuptools-0.6c9/setuptools/__init__.py	2008-09-24 12:10:35.000000000 -0500
--- ../../Enstaller/setuptools/__init__.py	2008-11-10 14:41:27.000000000 -0600
***************
*** 7,13 ****
  from distutils.util import convert_path
  import os.path
  
! __version__ = '0.6c9'
  __all__ = [
      'setup', 'Distribution', 'Feature', 'Command', 'Extension', 'Require',
      'find_packages'
--- 7,14 ----
  from distutils.util import convert_path
  import os.path
  
! # hacked from 0.6c9 so we know it is enstallers and comes *after* 0.6c9 in revision.
! __version__ = '0.6c9-s1'
  __all__ = [
      'setup', 'Distribution', 'Feature', 'Command', 'Extension', 'Require',
      'find_packages'
Only in ../../Enstaller/setuptools: __init__.py~
Only in ../../Enstaller/setuptools: __init__.pyc
diff -cr ../../setuptools-0.6c9/setuptools/package_index.py ../../Enstaller/setuptools/package_index.py
*** ../../setuptools-0.6c9/setuptools/package_index.py	2008-09-24 12:10:36.000000000 -0500
--- ../../Enstaller/setuptools/package_index.py	2008-11-14 10:51:01.000000000 -0600
***************
*** 141,148 ****
              if match:
                  yield urlparse.urljoin(url, htmldecode(match.group(1)))
  
! user_agent = "Python-urllib/%s setuptools/%s" % (
!     urllib2.__version__, require('setuptools')[0].version
  )
  
  
--- 141,148 ----
              if match:
                  yield urlparse.urljoin(url, htmldecode(match.group(1)))
  
! user_agent = "Python-urllib/%s enstaller/%s" % (
!     urllib2.__version__, require('enstaller')[0].version
  )
  
  
***************
*** 160,167 ****
          self.allows = re.compile('|'.join(map(translate,hosts))).match
          self.to_scan = []
  
- 
- 
      def process_url(self, url, retrieve=False):
          """Evaluate a URL as a possible download, and maybe retrieve it"""
          if url in self.scanned_urls and not retrieve:
--- 160,165 ----
***************
*** 283,290 ****
          else:
              return ""   # no sense double-scanning non-package pages
  
- 
- 
      def need_version_info(self, url):
          self.scan_all(
              "Page at %s links to .py file(s) without version info; an index "
--- 281,286 ----
***************
*** 323,331 ****
          return super(PackageIndex, self).obtain(requirement,installer)
  
  
- 
- 
- 
      def check_md5(self, cs, info, filename, tfp):
          if re.match('md5=[0-9a-f]{32}$', info):
              self.debug("Validating md5 checksum for %s", filename)
--- 319,324 ----
***************
*** 408,416 ****
          return getattr(self.fetch_distribution(spec, tmpdir),'location',None)
  
  
!     def fetch_distribution(self,
!         requirement, tmpdir, force_scan=False, source=False, develop_ok=False
!     ):
          """Obtain a distribution suitable for fulfilling `requirement`
  
          `requirement` must be a ``pkg_resources.Requirement`` instance.
--- 401,409 ----
          return getattr(self.fetch_distribution(spec, tmpdir),'location',None)
  
  
!     def fetch_distribution(self, requirement, tmpdir, force_scan=False,
!                            source=False, develop_ok=False, prefer_release=True
!                            ):
          """Obtain a distribution suitable for fulfilling `requirement`
  
          `requirement` must be a ``pkg_resources.Requirement`` instance.
***************
*** 426,442 ****
          checkout links will be considered.  Unless the `develop_ok` flag is
          set, development and system eggs (i.e., those using the ``.egg-info``
          format) will be ignored.
          """
  
          # process a Requirement
          self.info("Searching for %s", requirement)
          skipped = {}
  
!         def find(req):
              # Find a matching distribution; may be called more than once
! 
              for dist in self[req.key]:
  
                  if dist.precedence==DEVELOP_DIST and not develop_ok:
                      if dist not in skipped:
                          self.warn("Skipping development or system egg: %s",dist)
--- 419,445 ----
          checkout links will be considered.  Unless the `develop_ok` flag is
          set, development and system eggs (i.e., those using the ``.egg-info``
          format) will be ignored.
+ 
+         By default, release versions are preferred over development versions
+         (including alpha, beta, rc, etc...).  If prefer_release is set to False,
+         development versions will be accepted as well.
          """
  
          # process a Requirement
          self.info("Searching for %s", requirement)
          skipped = {}
  
!         def find(req, get_release=prefer_release):
              # Find a matching distribution; may be called more than once
!             # get release is initially set to True.  If no release version is
!             # found, find is called again with get_release set to false. Then
!             # development versions are searched for.
              for dist in self[req.key]:
  
+                 # get release versions by default
+                 if dist.is_non_release() and get_release:
+                     continue
+                 
                  if dist.precedence==DEVELOP_DIST and not develop_ok:
                      if dist not in skipped:
                          self.warn("Skipping development or system egg: %s",dist)
***************
*** 449,454 ****
--- 452,464 ----
                          location=self.download(dist.location, tmpdir)
                      )
  
+                 # If no release versions were found, search for latest
+                 #  development version.
+                 if get_release:
+                     self.info("No matching release version found. Searching for "\
+                               "latest development version.")
+                     return find(req, get_release=False)
+ 
          if force_scan:
              self.prescan()
              self.find_packages(requirement)
***************
*** 470,475 ****
--- 480,486 ----
              )
          return dist
  
+         
      def fetch(self, requirement, tmpdir, force_scan=False, source=False):
          """Obtain a file suitable for fulfilling `requirement`
  
***************
*** 484,495 ****
          return None
  
  
- 
- 
- 
- 
- 
- 
      def gen_setup(self, filename, fragment, tmpdir):
          match = EGG_FRAGMENT.match(fragment)
          dists = match and [d for d in
--- 495,500 ----
***************
*** 612,618 ****
              return self._attempt_download(url, filename)
  
  
- 
      def scan_url(self, url):
          self.process_url(url, True)
  
--- 617,622 ----
***************
*** 680,700 ****
      return entity_sub(decode_entity, text)
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  def open_with_auth(url):
      """Open a urllib2 request, handling HTTP authentication"""
  
--- 684,689 ----
***************
*** 726,741 ****
      return fp
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  def fix_sf_url(url):
      return url      # backward compatibility
  
--- 715,720 ----
***************
*** 765,779 ****
              {'content-type':'text/html'}, cStringIO.StringIO(body))
  
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- # this line is a kludge to keep the trailing blank lines for pje's editor
--- 744,746 ----
Only in ../../Enstaller/setuptools: package_index.py~
Only in ../../Enstaller/setuptools: package_index.pyc
Only in ../../Enstaller/setuptools: sandbox.pyc
Only in ../../Enstaller/setuptools: .svn
Only in ../../Enstaller/setuptools/tests: .svn
