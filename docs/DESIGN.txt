Enstaller design document

Rick Ratzel - initial rev: 2007-03-07

================================================================================

ez_enstaller_setup.py

   This script is intended as a one-time use script for bootstrapping the
enstaller eggs.  Similar to setuptools' ez_setup.py, ez_enstaller_setup.py will
check if the enstaller eggs are installed, and if not, will download and install
them using easy_install.  If easy_install is not installed, it will also
download and install easy_install as well.

   Because ez_enstaller_setup.py needs to do many of the same operations as
enstaller itself does, there is some duplication of code.  In particular, the
code to determine automatically what Enthought repository to use (since the eggs
are platform specific, and Enthought keeps platform specific eggs in different
repositories), and the code to perform the downloading and logging is
duplicated.  Rather than having enstaller use the code out of
ez_enstaller_setup.py, it seemed safer to just duplicate it since we can't
assume a user will have ez_enstaller_setup.py around all the time.

   There are a few enhancements planned for ez_enstaller_setup.py.  One is to
support -U, since ez_setup.py does and because it will solve a permission
problem on WIndows when re-writing the enstaller.exe file.

--------------------------------------------------------------------------------
bootstrapper.py

   This module is only used when Enstaller needs to be bootstrapped.  Unlike
ez_enstaller_setup.py which duplicates some code, if this module is called it
can be assumed that the entire Enstaller package is available for import (but
not all of the Enstaller dependencies!) and that it is probably being run from
a zipped egg in a temporary directory.

   The Bootstrapper class inherits from EasyInstaller, so it has all the
functionality of easy_install (assuming setuptools is installed).  The only
method a caller ever uses is bootstrap(), which is passed a destination dir and
an egg name.  For Enstaller, the ez_enstaller_setup.py script calls bootstrap(),
giving it an install location and the path to the latest Enstaller egg it just
downloaded to a temp dir.

   The first thing bootstrap() does is to download and install setuptools if it
cannot be imported.  This is done using the same code for finding the latest
version and downloading it that ez_enstaller_setup.py used to get the Enstaller
egg (a Downloader object).  Once the setuptools egg is available, it is
imported, giving the Bootstrapper the easy_install functionality it needs to
complete the bootstrap() call.  At this point, the Bootstrapper uses
easy_install (via the now-functional EasyInstaller methods it inherited) to
install the Enstaller egg previously downloaded to the temp dir.  easy_install
installs the Enstaller egg to its final location, examines its dependencies
(stored in the egg's EGG-INFO dir) and downloads and installs them as well.

--------------------------------------------------------------------------------
launcher.py

   The launcher.py module defines the Launcher class, which is used for
launching Enstaller.  There are no references to the Launcher class in the
Enstaller source code since it is only used as a setuptools entry point (see
setup.py).  This means that when the Enstaller egg is installed, setuptools will
create a script automatically which makes a call to the launch() function in the
launcher.py module.  This function instantiates a Launcher, passing it the
sys.argv list to start the app.

   The purpose of the Launcher class is to have a single call to main() (as
defined in main.py below), wrapped in an exception handler to catch all uncaught
exceptions and format them into a "post mortem" file.  The post mortem file can
then be sent back to Enthought in the event that Enstaller crashes.  And as
mentiond before, the launch() function also provides for the setuptools
"console_scripts" entry point.

--------------------------------------------------------------------------------
main.py

   This module sets up the appropriate objects for a standalone Enstaller
session.  Developers wishing to embed Enstaller into their application should
look at this module to see how it can be done.

   There are no classes in this module, instead only a series of free functions
for processing the command-line and one for starting a standalone Enstaller app
named main().

   main() simply calls the command-line processor, gets the processed args and
uses them to instantiate a Enstaller Session object.  The Session is the "heart"
of the app and is the object which the CLI, GUI, and any other
Enstaller-embedded app will use.  The Session is immediately initialized,
triggering a scan of all the installed packages on the interpreter's search path
(sys.path).  This scan is required for all Enstaller operations.

   Once the Session is initialized, the command-line args are used to determine
if a GUI is to be used, or a CLI.  The appropriate UI is instantiated and the
session is assigned to it.  If a CLI is used, the command issued via the
command-line is used to determine which method on the CLI instance to call, it
is called and the return code is returned from main.  If a GUI is used, the
show() method is called which basically starts the GUI mainloop.  The return
value from show() is returned from main.

--------------------------------------------------------------------------------
session.py

   As mentioned above, this module can be considered the "heart" of Enstaller.
The Session is responsible for all Enstaller operations: installing, removing,
activating, deactivating, finding/listing installed and repository packages,
etc.  Both the Enstaller CLI and GUI share it, making these interface layers
(especially the CLI) relatively thin.

   The Session has an install_dir trait, a list of URLs used to look for
installable packages, an instance of an Engine for doing the actual package
installing, removing, etc., an instance of a PreferenceManager for reading and
writing prefs to/from config files, a list of Repository objects containing data
on packages available for download, and a list of LocalRepository objects for
installed packages (installed package dirs use LocalRepository objects...need
less confusing name since repository is used mainly for something you download
from?).

   While the Engine performs the installing, removing, downloading, etc.  The
Session object is important for maintaining the state of the session and the
environment Enstaller is working in.  The Engine knows nothing of what packages
are available or what package directories to look at until the Session informs
it of them and keeping it up-to-date when something changes.  All Enstaller
operations go through Session before Engine and never go directly to
Engine.

--------------------------------------------------------------------------------
enstaller_engine.py
easy_installer.py

   The Enstaller Engine extends EasyInstaller with features unique to Enstaller
such as removing, post-install, and modifying RPATHs in binaries (*nix only).
Some embedders may wish to embed this class in their app instead of an Enstaller
Session, but it should be noted that functionality that requires knowledge of
the packages installed or available for download/install, as well as using user
configuration file settings will be absent.

   EasyInstaller embeds the "main" of setuptools' easy_install entry point, and
at the moment provides only an install() method which accepts a destination dir
and pacakge spec (same spec style used by easy_install).  Attributes on
EasyInstaller include find_links, always_unzip, script_dir, and several others
which correspond to easy_install command-line args.  This class does not use
Traits (the Engine does though) since it is used by the bootstrapping code, and
Traits may not be installed at that time.

--------------------------------------------------------------------------------
repository.py
local_repository.py
remote_repository.py
pypi_repository.py
repository_factory.py

   With the exception of repository_factory, these classes maintain a list of
Package objects.  The Repository classes differ in how they populate the list of
packages.  When a Repository class is destroyed, all package objects it
maintains are destroyed too (using standard Python GC rules).

   The Repository class is an abstract base class where most of its methods are
overridden in derived classes.  The two that usually are not are
build_package_list() and find_packages(), both of which operate on a list of
packages that has already been populated.

   The LocalRepository class is used for repositories that are local (on disk
accessible through the file system).  It is also used for maintaining a list of
packages which are already installed, which could be confusing since the term
repository is used for a group of packages *not* installed.

   The RemoteRepository class is used for repositories that are not local,
accessed through the internet with a series of http calls.

   The PypiRepository class is used for PyPI-style repositories, like
cheeseshop, which support either XMLRPC calls, or have a specific heirarchy of
html pages used for organizing the packages.

   The repository_factory module contains a single function, create_repository()
which returns an instance of a Repository object based on the type of URL it is
passed (a local path or file:// returns a LocalRepository, a URL which accepts
XMLRPC returns a PypiRepository, all others return a RemoteRepository).

--------------------------------------------------------------------------------
package.py

   The Package class maintains all information about any given package.
Multiple versions of the same package result in multiple Package objects...only
one version of a package per Package instance.

   Package objects are instantiated within the various Repository classes.  Each
Package object keeps several traits describing information on the package mainly
gathered from reading meta-data files and dissecting the file name.  The only
action a Package object can do is toggle its active state, and even then it
simply passes the call through to the Repository object which owns it (maybe
this method should be removed).  Beyond that, Package objects exist primarily
for holding package data.

--------------------------------------------------------------------------------
cli.py

   The CLI class is the command-line interface to an Enstaller Session.  It is
instantiated from main() in main.py and contains an instance of a single
EnstallerSession, setup in main() and assigned to a CLI object.

   A CLI usually accepts only a single method call from main(), passes the call
through to the Session, reads the result and formats it into text to output to
STDOUT.  There is no reason several method calls couldn't be made, but at the
moment, main() processes only a single action from the command-line.

--------------------------------------------------------------------------------
gui*.py
package_row.py   
package_table*.py

   These modules make up the Enstaller GUI.  There are two types of views used
in the GUI: the "main" GUI view for displaying the log output, tables of
packages, and top button row, and the "table" view used for displaying the table
of packages, the meta-data pane, and the action buttons for each table.

   The GUI class is the model for the "main" view, and like the CLI, consists
primarily of an instance of an Enstaller Session.  Unlike the CLI, it adds
button objects and the ability to run several Session operations in a single
session, in a background thread.

   gui_view.py contains the view and controller instances/classes for the
EnstallerGUI model.

   The PackageTable classes (PackageTable and RepositoryPackageTable) are the
models for the tables of packages to display.  Each package is represented by a
PackageRow, and the different types of PackageTables use different types of
packageRows.

   package_table_view.py and package_table_columns.py contain the view and
controller instances/classes for the PackageTable models.

   The PackageRow classes (PackageRow, InstalledPackageRow,
RepositoryPackageRow) contain references to one or more Package objects (the
only reason for multiple package objects is so multiple versions of the same
package only use one row in the table).  The PackageRow classes (and the
PackageTable handlers/controllers which operate on them) are fairly complex in
order to support the GUI features they provide (state-dependent actions,
selecting multiple versions, etc.).

